#!/bin/bash
set -euo pipefail

# generated by
# > man githooks | grep '^   [a-z]' | sort | xargs
all_hooks=(applypatch-msg commit-msg post-applypatch post-checkout post-commit post-merge post-receive post-rewrite post-update pre-applypatch pre-auto-gc pre-commit prepare-commit-msg pre-push pre-rebase pre-receive push-to-checkout update)

set_defaults() {
    GIT_DIR="${GIT_DIR-$PWD/.git}"
    GIT_WORK_TREE="${GIT_WORK_TREE-$PWD}"
    GITHOOKS_DIR="${GITHOOKS_DIR-}"

    GITHOOKS_USE_ABSOLUTE_HOOKSDIR="${GITHOOKS_USE_ABSOLUTE_HOOKSDIR-no}"

    export SIMPLE_BACKUP_SUFFIX="${GITHOOKS_BACKUP_SUFFIX-.backup}"
    export VERSION_CONTROL="${GITHOOKS_BACKUP_VERSION_CONTROL-numbered}"

    XDG_CONFIG_HOME="${XDG_CONFIG_HOME-$HOME/.config}"
    githooks_dirs=("$XDG_CONFIG_HOME/git/hooks" "$HOME/.githooks")
    if is_truish "$GITHOOKS_USE_ABSOLUTE_HOOKSDIR"; then
        githooks_dirs+=("$GITHOOKS_DIR")
    else
        githooks_dirs+=("$GIT_WORK_TREE/${GITHOOKS_DIR-.githooks}")
    fi
}

usage() {
    cat <<EOF
USAGE: $0 install [-g] [-d GITHOOKS_DIR]
  or:  $0 run some_git_hook [...]
  or:  some_git_hook [...]

Use the following options when installing hooks.
  -d GITHOOKS_DIR   run hooks in the dir argument,
  -g                use global GITHOOKS_DIR (i.e. don't prepend GIT_WORK_TREE)

Use the following environment variables when installing hooks.
Note that command line switches take precedence.
  GITHOOKS_BACKUP_SUFFIX             when installing hook, how to name
                                     backup hook scripts, see cp(1).
  GITHOOKS_BACKUP_VERSION_CONTROL    when installing hook, how to version
                                     backups, see cp(1).

EOF
}

is_truish() {
    [[ "$1" == y* ]]
}

err() {
    echo "$@" >&2
}

scriptdirpath() {
    (cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
}

scriptpath() {
    echo "$(scriptdirpath)/$(basename "${BASH_SOURCE[0]}")"
}

is_hook() {
    local scriptname
    scriptname="$(basename "$1")"

    # This is not space-safe. That does not matter here.
    [[ " ${all_hooks[@]} " =~ " ${scriptname} " ]]
}

install_hook() {
    local hook="$1"
    local hooks_file="$GIT_DIR/hooks/$hook"

    if is_truish "GITHOOKS_IS_ABSOLUTE" || [ -n "$GITHOOKS_DIR" ]; then
        local tmpfile; tmpfile="$(mktemp)"
        cat <<EOF > "$tmpfile"
#!/bin/sh
GITHOOKS_DIR="$GITHOOKS_DIR" GITHOOKS_USE_ABSOLUTE_HOOKSDIR="$GITHOOKS_USE_ABSOLUTE_HOOKSDIR" \
    exec "$(scriptpath)" run "$hook" "\$@"
EOF
        chmod +x "$tmpfile"
        mv -b "$tmpfile" "$hooks_file"
    else
        ln -bs "$(scriptpath)" "$hooks_file"
    fi
}

install_all_hooks() {
    for hook in "${all_hooks[@]}"; do
        install_hook "$hook"
    done
}

run_hook() {
    # This relies on set -e (above) to fail when a hook fails.
    local hook="$1"
    shift

    for dir in "${githooks_dirs[@]}"; do
        for file in "$dir/${hook}"{.d/*,}; do
            err "---> candidate hook $file"
            if [ -x "$file" ] && ! [ -d "$file" ]; then
                err "---> Running hook $file"
                err
                $file "$@"
            fi
        done
    done
}

set_defaults

if is_hook "$0"; then
    hook="$(basename "$0")"
    run_hook "$hook" "$@"
elif [ "$#" -eq 0 ]; then
    usage
    exit 1
elif [ "$1" = run ] && [ "$#" -ge 2 ]; then
    hook="$2"
    shift; shift
    run_hook "$hook" "$@"
elif [ "$1" = install ]; then
    shift
    install_all_hooks
elif [ "$1" = usage ]; then
    usage
else
    usage
    exit 1
fi
